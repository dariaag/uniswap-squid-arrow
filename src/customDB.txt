import {
  Entity,
  EntityClass,
  FindOneOptions,
  IsolationLevel,
} from "@subsquid/typeorm-store";
import { createOrmConfig } from "@subsquid/typeorm-config";
import {
  DatabaseState,
  FinalTxInfo,
  HashAndHeight,
} from "@subsquid/typeorm-store/lib/interfaces";
import { Store } from "./wrapper";
import {
  DataSource,
  EntityManager,
  EntityTarget,
  FindManyOptions,
  FindOptionsWhere,
} from "typeorm";
import { Table, Dest, TableWriter, DatabaseHooks } from "@subsquid/file-store";
import assert from "assert";
import { assertNotNull } from "@subsquid/evm-processor";
import { ChangeTracker, rollbackBlock } from "@subsquid/typeorm-store/lib/hot";
import { S3Dest } from "@subsquid/file-store-s3";
import { ColumnMetadata } from "typeorm/metadata/ColumnMetadata";
import { splitIntoBatches } from "./utils/tools";
export type Database<S> = FinalDatabase<S>;
export interface FinalDatabase<S> {
  supportsHotBlocks?: false;
  connect(): Promise<HashAndHeight>;
  transact(info: FinalTxInfo, cb: (store: S) => Promise<void>): Promise<void>;
}
export type Tables = Record<string, Table<any>>;
export type DataBuffer<T extends Tables> = {
  [k in keyof T]: TableWriter<T[k] extends Table<infer R> ? R : never>;
};
//implement db with store.
interface StoreConstructor<T extends Tables> {
  new (chunk: () => DataBuffer<T>): Store<T>;
}
export interface DatabaseOptions<T extends Tables, D extends S3Dest> {
  tables: T;
  dest: D;
  chunkSizeMb?: number;
  syncIntervalBlocks?: number;
  hooks?: DatabaseHooks<D>;
}

export class CustomDatabase<T extends Tables, D extends S3Dest>
  implements FinalDatabase<Store<T>>
{
  //from orm
  private statusSchema: string;
  private isolationLevel: IsolationLevel;
  private con?: DataSource;
  private projectDir: string;

  //from final
  private tables: T;
  private dest: D;
  private chunkSize: number;
  private updateInterval: number;
  private hooks: DatabaseHooks<D>;

  private StoreConstructor: StoreConstructor<T>;

  private chunk?: DataBuffer<T>;
  private state?: HashAndHeight;
  constructor(options: DatabaseOptions<T, D>) {
    //orm
    this.statusSchema = "squid_processor";
    this.isolationLevel = "SERIALIZABLE";
    this.projectDir = process.cwd();
    //filestore
    this.tables = options.tables;
    this.dest = options.dest;

    this.chunkSize = options?.chunkSizeMb ?? 20;
    this.updateInterval = options?.syncIntervalBlocks || Infinity;
    this.hooks = options.hooks || defaultHooks;
    class Store<T extends Tables> {
      //data: Stores<T>;

      constructor(
        private em: () => EntityManager,
        protected chunk: () => DataBuffer<T>,
        private changes?: ChangeTracker
      ) {}

      /**
       * Alias for {@link Store.upsert}
       */
      save<E extends Entity>(entity: E): Promise<void>;
      save<E extends Entity>(entities: E[]): Promise<void>;
      save<E extends Entity>(e: E | E[]): Promise<void> {
        if (Array.isArray(e)) {
          // please the compiler
          return this.upsert(e);
        } else {
          return this.upsert(e);
        }
      }

      /**
       * Upserts a given entity or entities into the database.
       *
       * It always executes a primitive operation without cascades, relations, etc.
       */
      upsert<E extends Entity>(entity: E): Promise<void>;
      upsert<E extends Entity>(entities: E[]): Promise<void>;
      async upsert<E extends Entity>(e: E | E[]): Promise<void> {
        if (Array.isArray(e)) {
          if (e.length == 0) return;
          let entityClass = e[0].constructor as EntityClass<E>;
          for (let i = 1; i < e.length; i++) {
            assert(
              entityClass === e[i].constructor,
              "mass saving allowed only for entities of the same class"
            );
          }
          await this.changes?.trackUpsert(entityClass, e);
          await this.saveMany(entityClass, e);
        } else {
          let entityClass = e.constructor as EntityClass<E>;
          await this.changes?.trackUpsert(entityClass, [e]);
          await this.em().upsert(entityClass, e as any, ["id"]);
        }
      }

      private async saveMany(
        entityClass: EntityClass<any>,
        entities: any[]
      ): Promise<void> {
        assert(entities.length > 0);
        let em = this.em();
        let metadata = em.connection.getMetadata(entityClass);
        let fk = metadata.columns.filter((c) => c.relationMetadata);
        if (fk.length == 0) return this.upsertMany(em, entityClass, entities);
        let currentSignature = this.getFkSignature(fk, entities[0]);
        let batch = [];
        for (let e of entities) {
          let sig = this.getFkSignature(fk, e);
          if (sig === currentSignature) {
            batch.push(e);
          } else {
            await this.upsertMany(em, entityClass, batch);
            currentSignature = sig;
            batch = [e];
          }
        }
        if (batch.length) {
          await this.upsertMany(em, entityClass, batch);
        }
      }

      private getFkSignature(fk: ColumnMetadata[], entity: any): bigint {
        let sig = 0n;
        for (let i = 0; i < fk.length; i++) {
          let bit = fk[i].getEntityValue(entity) === undefined ? 0n : 1n;
          sig |= bit << BigInt(i);
        }
        return sig;
      }

      private async upsertMany(
        em: EntityManager,
        entityClass: EntityClass<any>,
        entities: any[]
      ): Promise<void> {
        for (let b of splitIntoBatches(entities, 1000)) {
          await em.upsert(entityClass, b as any, ["id"]);
        }
      }

      /**
       * Inserts a given entity or entities into the database.
       * Does not check if the entity(s) exist in the database and will fail if a duplicate is inserted.
       *
       * Executes a primitive INSERT operation without cascades, relations, etc.
       */
      insert<E extends Entity>(entity: E): Promise<void>;
      insert<E extends Entity>(entities: E[]): Promise<void>;
      async insert<E extends Entity>(e: E | E[]): Promise<void> {
        if (Array.isArray(e)) {
          if (e.length == 0) return;
          let entityClass = e[0].constructor as EntityClass<E>;
          for (let i = 1; i < e.length; i++) {
            assert(
              entityClass === e[i].constructor,
              "mass saving allowed only for entities of the same class"
            );
          }
          await this.changes?.trackInsert(entityClass, e);
          for (let b of splitIntoBatches(e, 1000)) {
            await this.em().insert(entityClass, b as any);
          }
        } else {
          let entityClass = e.constructor as EntityClass<E>;
          await this.changes?.trackInsert(entityClass, [e]);
          await this.em().insert(entityClass, e as any);
        }
      }

      /**
       * Deletes a given entity or entities from the database.
       *
       * Unlike {@link EntityManager.remove} executes a primitive DELETE query without cascades, relations, etc.
       */
      remove<E extends Entity>(entity: E): Promise<void>;
      remove<E extends Entity>(entities: E[]): Promise<void>;
      remove<E extends Entity>(
        entityClass: EntityClass<E>,
        id: string | string[]
      ): Promise<void>;
      async remove<E extends Entity>(
        e: E | E[] | EntityClass<E>,
        id?: string | string[]
      ): Promise<void> {
        if (id == null) {
          if (Array.isArray(e)) {
            if (e.length == 0) return;
            let entityClass = e[0].constructor as EntityClass<E>;
            for (let i = 1; i < e.length; i++) {
              assert(
                entityClass === e[i].constructor,
                "mass deletion allowed only for entities of the same class"
              );
            }
            let ids = e.map((i) => i.id);
            await this.changes?.trackDelete(entityClass, ids);
            await this.em().delete(entityClass, ids);
          } else {
            let entity = e as E;
            let entityClass = entity.constructor as EntityClass<E>;
            await this.changes?.trackDelete(entityClass, [entity.id]);
            await this.em().delete(entityClass, entity.id);
          }
        } else {
          let entityClass = e as EntityClass<E>;
          await this.changes?.trackDelete(
            entityClass,
            Array.isArray(id) ? id : [id]
          );
          await this.em().delete(entityClass, id);
        }
      }

      async count<E extends Entity>(
        entityClass: EntityClass<E>,
        options?: FindManyOptions<E>
      ): Promise<number> {
        return this.em().count(entityClass, options);
      }

      async countBy<E extends Entity>(
        entityClass: EntityClass<E>,
        where: FindOptionsWhere<E> | FindOptionsWhere<E>[]
      ): Promise<number> {
        return this.em().countBy(entityClass, where);
      }

      async find<E extends Entity>(
        entityClass: EntityClass<E>,
        options?: FindManyOptions<E>
      ): Promise<E[]> {
        return this.em().find(entityClass, options);
      }

      async findBy<E extends Entity>(
        entityClass: EntityClass<E>,
        where: FindOptionsWhere<E> | FindOptionsWhere<E>[]
      ): Promise<E[]> {
        return this.em().findBy(entityClass, where);
      }

      async findOne<E extends Entity>(
        entityClass: EntityClass<E>,
        options: FindOneOptions<E>
      ): Promise<E | undefined> {
        return this.em().findOne(entityClass, options).then(noNull);
      }

      async findOneBy<E extends Entity>(
        entityClass: EntityClass<E>,
        where: FindOptionsWhere<E> | FindOptionsWhere<E>[]
      ): Promise<E | undefined> {
        return this.em().findOneBy(entityClass, where).then(noNull);
      }

      async findOneOrFail<E extends Entity>(
        entityClass: EntityTarget<E>,
        options: FindOneOptions<E>
      ): Promise<E> {
        return this.em().findOneOrFail(entityClass, options);
      }

      async findOneByOrFail<E extends Entity>(
        entityClass: EntityTarget<E>,
        where: FindOptionsWhere<E> | FindOptionsWhere<E>[]
      ): Promise<E> {
        return this.em().findOneByOrFail(entityClass, where);
      }

      get<E extends Entity>(
        entityClass: EntityClass<E>,
        optionsOrId: FindOneOptions<E> | string
      ): Promise<E | undefined> {
        if (typeof optionsOrId == "string") {
          return this.findOneBy(entityClass, { id: optionsOrId } as any);
        } else {
          return this.findOne(entityClass, optionsOrId);
        }
      }
    }
    function* splitIntoBatches<T>(
      list: T[],
      maxBatchSize: number
    ): Generator<T[]> {
      if (list.length <= maxBatchSize) {
        yield list;
      } else {
        let offset = 0;
        while (list.length - offset > maxBatchSize) {
          yield list.slice(offset, offset + maxBatchSize);
          offset += maxBatchSize;
        }
        yield list.slice(offset);
      }
    }

    function noNull<T>(val: null | undefined | T): T | undefined {
      return val == null ? undefined : val;
    }
    for (let name in this.tables) {
      Object.defineProperty(Store.prototype, name, {
        get(this: Store<T>) {
          return this.chunk()[name];
        },
      });
    }
    this.StoreConstructor = Store<T> as any;
  }

  async connect(): Promise<DatabaseState> {
    assert(this.con == null, "already connected");
    this.state = await this.getTableState();
    let names = await this.dest.readdir("./");
    for (let name of names) {
      let chunkStart = Number(name.split("-")[0]);
      if (chunkStart > this.state.height) {
        await this.dest.rm(name);
      }
    }
    let cfg = createOrmConfig({ projectDir: this.projectDir });
    this.con = new DataSource(cfg);

    await this.con.initialize();

    try {
      return await this.con.transaction("SERIALIZABLE", (em) =>
        this.initTransaction(em)
      );
    } catch (e: any) {
      await this.con.destroy().catch(() => {}); // ignore error
      this.con = undefined;
      throw e;
    }
  }
  async disconnect(): Promise<void> {
    await this.con?.destroy().finally(() => (this.con = undefined));
  }

  private async initTransaction(em: EntityManager): Promise<DatabaseState> {
    let schema = this.escapedSchema();

    await em.query(`CREATE SCHEMA IF NOT EXISTS ${schema}`);
    await em.query(
      `CREATE TABLE IF NOT EXISTS ${schema}.status (` +
        `id int4 primary key, ` +
        `height int4 not null, ` +
        `hash text DEFAULT '0x', ` +
        `nonce int4 DEFAULT 0` +
        `)`
    );
    await em.query(
      // for databases created by prev version of typeorm store
      `ALTER TABLE ${schema}.status ADD COLUMN IF NOT EXISTS hash text DEFAULT '0x'`
    );
    await em.query(
      // for databases created by prev version of typeorm store
      `ALTER TABLE ${schema}.status ADD COLUMN IF NOT EXISTS nonce int DEFAULT 0`
    );
    await em.query(
      `CREATE TABLE IF NOT EXISTS ${schema}.hot_block (height int4 primary key, hash text not null)`
    );
    await em.query(
      `CREATE TABLE IF NOT EXISTS ${schema}.hot_change_log (` +
        `block_height int4 not null references ${schema}.hot_block on delete cascade, ` +
        `index int4 not null, ` +
        `change jsonb not null, ` +
        `PRIMARY KEY (block_height, index)` +
        `)`
    );

    let status: (HashAndHeight & { nonce: number })[] = await em.query(
      `SELECT height, hash, nonce FROM ${schema}.status WHERE id = 0`
    );
    if (status.length == 0) {
      await em.query(
        `INSERT INTO ${schema}.status (id, height, hash) VALUES (0, -1, '0x')`
      );
      status.push({ height: -1, hash: "0x", nonce: 0 });
    }

    let top: HashAndHeight[] = await em.query(
      `SELECT height, hash FROM ${schema}.hot_block ORDER BY height`
    );

    return assertStateInvariants({ ...status[0], top });
  }
  private async getState(em: EntityManager): Promise<DatabaseState> {
    let schema = this.escapedSchema();

    let status: (HashAndHeight & { nonce: number })[] = await em.query(
      `SELECT height, hash, nonce FROM ${schema}.status WHERE id = 0`
    );

    assert(status.length == 1);

    let top: HashAndHeight[] = await em.query(
      `SELECT hash, height FROM ${schema}.hot_block ORDER BY height`
    );

    return assertStateInvariants({ ...status[0], top });
  }

  private createChunk(): DataBuffer<T> {
    let chunk = {} as DataBuffer<T>;
    for (let name in this.tables) {
      chunk[name] = this.tables[name].createWriter();
    }
    return chunk;
  }

  async transact(
    info: FinalTxInfo,
    cb: (store: Store<T>) => Promise<void>
  ): Promise<void> {
    let dbState = await this.getTableState();
    let prevState = assertNotNull(this.state, "not connected");
    let { nextHead: newState } = info;

    assert(
      dbState.hash === prevState.hash && dbState.height === prevState.height,
      "state was updated by foreign process, make sure no other processor is running"
    );
    assert(prevState.height < newState.height);
    assert(prevState.hash != newState.hash);

    this.chunk = this.chunk || this.createChunk();
    await this.performTableUpdates(cb, this.chunk);
    let chunkSize = 0;
    for (let name in this.chunk) {
      chunkSize += this.chunk[name].size;
    }

    if (
      chunkSize >= this.chunkSize * 1024 * 1024 || //info.isOnTop &&
      newState.height - prevState.height >= this.updateInterval
    ) {
      if (chunkSize > 0) {
        await this.flush(prevState, newState, this.chunk);
      }
      await this.hooks.onStateUpdate(this.dest, newState);
      this.state = newState;
    }
    //ORM
    return this.submit(async (em) => {
      let state = await this.getState(em);
      let { prevHead: prev, nextHead: next } = info;

      assert(state.hash === info.prevHead.hash, RACE_MSG);
      assert(state.height === prev.height);
      assert(prev.height < next.height);
      assert(prev.hash != next.hash);

      for (let i = state.top.length - 1; i >= 0; i--) {
        let block = state.top[i];
        await rollbackBlock(this.statusSchema, em, block.height);
      }

      await this.performUpdates(cb, em);

      await this.updateStatus(em, state.nonce, next);
    });
  }

  private async flush(
    prevState: HashAndHeight,
    newState: HashAndHeight,
    chunk: DataBuffer<T>
  ) {
    let folderName = createFolderName(prevState.height + 1, newState.height);
    await this.dest.transact(folderName, async (txDest) => {
      for (let tableAlias in this.tables) {
        await txDest.writeFile(
          `${this.tables[tableAlias].name}`,
          chunk[tableAlias].flush()
        );
      }
    });
  }
  private deleteHotBlocks(
    em: EntityManager,
    finalizedHeight: number
  ): Promise<void> {
    return em.query(
      `DELETE FROM ${this.escapedSchema()}.hot_block WHERE height <= $1`,
      [finalizedHeight]
    );
  }

  private insertHotBlock(
    em: EntityManager,
    block: HashAndHeight
  ): Promise<void> {
    return em.query(
      `INSERT INTO ${this.escapedSchema()}.hot_block (height, hash) VALUES ($1, $2)`,
      [block.height, block.hash]
    );
  }
  private async performTableUpdates(
    cb: (store: Store<T>) => Promise<void>,
    chunk: DataBuffer<T>
  ): Promise<void> {
    let running = true;
    let store = new this.StoreConstructor(() => {
      assert(running, `too late to perform updates`);
      return chunk;
    });

    try {
      await cb(store);
    } finally {
      running = false;
    }
  }

  private async getTableState(): Promise<HashAndHeight> {
    let state = await this.hooks.onStateRead(this.dest);
    if (state == null) {
      state = { height: -1, hash: "0x" };
      await this.hooks.onStateUpdate(this.dest, state);
    }
    assert(Number.isSafeInteger(state.height));
    return state;
  }

  private async updateStatus(
    em: EntityManager,
    nonce: number,
    next: HashAndHeight
  ): Promise<void> {
    let schema = this.escapedSchema();

    let result: [data: any[], rowsChanged: number] = await em.query(
      `UPDATE ${schema}.status SET height = $1, hash = $2, nonce = nonce + 1 WHERE id = 0 AND nonce = $3`,
      [next.height, next.hash, nonce]
    );

    let rowsChanged = result[1];

    // Will never happen if isolation level is SERIALIZABLE or REPEATABLE_READ,
    // but occasionally people use multiprocessor setups and READ_COMMITTED.
    assert.strictEqual(rowsChanged, 1, RACE_MSG);
  }

  private async performUpdates(
    cb: (store: Store<T>) => Promise<void>,
    em: EntityManager,
    changeTracker?: ChangeTracker
  ): Promise<void> {
    let running = true;

    let store = new Store<T>(() => {
      assert(
        running,
        `too late to perform db updates, make sure you haven't forgot to await on db query`
      );
      return em;
      //@ts-ignore
    }, changeTracker);

    try {
      await cb(store);
    } finally {
      running = false;
    }
  }

  private async submit(
    tx: (em: EntityManager) => Promise<void>
  ): Promise<void> {
    let retries = 3;
    while (true) {
      try {
        let con = this.con;
        assert(con != null, "not connected");
        return await con.transaction(this.isolationLevel, tx);
      } catch (e: any) {
        if (e.code == "40001" && retries) {
          retries -= 1;
        } else {
          throw e;
        }
      }
    }
  }

  private escapedSchema(): string {
    let con = assertNotNull(this.con);
    return con.driver.escape(this.statusSchema);
  }
}

const DEFAULT_STATUS_FILE = `status.txt`;
const defaultHooks: DatabaseHooks = {
  async onStateRead(dest) {
    if (await dest.exists(DEFAULT_STATUS_FILE)) {
      let [height, hash] = await dest
        .readFile(DEFAULT_STATUS_FILE)
        .then((d) => d.split("\n"));
      return { height: Number(height), hash: hash || "0x" };
    } else {
      return undefined;
    }
  },
  async onStateUpdate(dest, info) {
    await dest.writeFile(DEFAULT_STATUS_FILE, info.height + "\n" + info.hash);
  },
};
const RACE_MSG =
  "status table was updated by foreign process, make sure no other processor is running";
function assertStateInvariants(state: DatabaseState): DatabaseState {
  let height = state.height;

  // Sanity check. Who knows what driver will return?
  assert(Number.isSafeInteger(height));

  assertChainContinuity(state, state.top);

  return state;
}

function assertChainContinuity(base: HashAndHeight, chain: HashAndHeight[]) {
  let prev = base;
  for (let b of chain) {
    assert(b.height === prev.height + 1, "blocks must form a continues chain");
    prev = b;
  }
}
export function createFolderName(from: number, to: number) {
  let name =
    from.toString().padStart(10, "0") + "-" + to.toString().padStart(10, "0");
  assert(isFolderName(name));
  return name;
}

export function isFolderName(str: string) {
  return /^(\d+)-(\d+)$/.test(str);
}
